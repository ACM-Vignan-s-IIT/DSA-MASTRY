# DSA-BASIC-TO-ADVANCED

<!-- This repository covers a range of Data Structures and Algorithms (DSA) implementations, spanning from introductory to advanced levels. -->
This repository covers the roadmap for mastering Data Structures and Algorithms in JavaScript, Python, C/C++, and Java.

|       | &emsp;&emsp;&emsp;&emsp; **TABLE OF CONTENTS** &emsp;&emsp;&emsp;&emsp;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| :---: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   •   | [**DSA Roadmap**](#data-structures-and-algorithms-roadmap)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|   •   | [**JavaScript DSA**](#javascript---data-structures-and-algorithms)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|   •   | [**Python DSA**](#python---data-structures-and-algorithms)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|   •   | [**C/C++ DSA**](#cc---data-structures-and-algorithms)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|   •   | [**Java DSA**](#java---data-structures-and-algorithms)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|   •   | <details> <summary><a href="#dsa-practice-sheets"><b>DSA Practice Sheets</b></a></summary> <p> ◌ <a href="#1-strivers-sde-sheet--top-coding-interview-problems">Strivers DSA Cheat Sheet</a> <br/> ◌ <a href="#2-dsa-sheet-by-love-babbar">Love Babar DSA Cheat Sheet</a>  <br/> ◌ <a href="#3-apna-college-dsa-sheet">Apna College DSA Cheat Sheet</a>  <br/> ◌ <a href="#4-neetcode-150">NeetCode 150 DSA Cheat Sheet</a>  <br/> ◌ <a href="#5-dsa-sheet-by-arsh-45–60-days-plan">DSA Sheet by Arsh (45–60 Days Plan)</a>  <br/> ◌ <a href="#6-algopreps-151-problems-sheet">AlgoPrep’s 151 Problems Sheet</a> </p> </details> |  |

<!-- <p> <a href="#dsa-basic-to-advanced">• Strivers DSA Cheat Sheet</a> <br/> <a href="#dsa-basic-to-advanced">• Love Babar DSA Cheat Sheet</a> </p> -->

## Data Structures and Algorithms Roadmap

## 5 steps to Mastering DSA

Mastering DSA as a beginner is simplified into 5 steps:

1. Choose a programming language.
2. Understand time and space complexities.
3. Learn basic data structures and algorithms.
4. Practice a lot.
5. Join competitions to get really good.

| Steps | Table of Contents                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :---: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  1.   | [**Master at least one Programming Language**](#1-master-at-least-one-programming-language)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|  2.   | [**Understand Complexities**](#2-understand-complexities)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|  3.   | <details><summary><a href="#3-learn-essential-data-structures-and-algorithms"><b>Learn essential Data Structures and Algorithms, including:</b></a></summary><p>◌ <a href="#31-array">**3.1 - Array**</a><br>◌ <a href="#32-string">**3.2 - String**</a><br>◌ <a href="#33-linked-list">**3.3 - Linked List**</a><br>◌ <a href="#34-searching-algorithm">**3.4 - Searching Algorithm**</a><br>◌ <a href="#35-sorting-algorithm">**3.5 - Sorting Algorithm**</a><br>◌ <a href="#36-divide-and-conquer-algorithm">**3.6 - Divide and Conquer Algorithm**</a><br>◌ <a href="#37-stack">**3.7 - Stack**</a><br>◌ <a href="#38-queue">**3.8 - Queue**</a><br>◌ <a href="#39-tree-data-structure">**3.9 - Tree Data Structure**</a><br>◌ <a href="#310-graph-data-structure">**3.10 - Graph Data Structure**</a><br>◌ <a href="#311-greedy-methodology">**3.11 - Greedy Methodology**</a><br>◌ <a href="#312-recursion">**3.12 - Recursion**</a><br>◌ <a href="#313-backtracking-algorithm">**3.13 - Backtracking Algorithm**</a><br>◌ <a href="#314-dynamic-programming">**3.14 - Dynamic Programming**</a></p></details> |
|  4.   | [**Practice consistently and extensively**](#4-practice-consistently-and-extensively)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|  5.   | [**Compete to advance and become proficient**](#5-compete-to-advance-and-become-proficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

## 1. Master at least one Programming Language

Embark on your data structures and algorithms journey by mastering a programming language. Just as we learn the alphabet and grammar before writing essays, understanding the basics of a language is essential for programming.

Choose a language, whether it's Java, C, C++, Python, or any other of your preference. Before diving into coding, grasp the foundational elements of the language, including basic syntax, data types, variables, operators, conditional statements, loops, functions, etc. Optionally, explore Object-Oriented Programming (OOP) concepts to strengthen your coding foundation.

## 2. Understand Complexities

Now, let's delve into an interesting and crucial topic. The main goal of using DSA is to solve problems effectively and efficiently. How do you assess if your program is efficient? This is where complexities come in, and there are two types:

1. **Time Complexity:** It measures the time needed to execute the code.
2. **Space Complexity:** It indicates the space required for the code to function successfully.

In DSA, you'll often encounter the term Auxiliary Space, referring to extra space used in the program beyond the input data structure.

It overlooks system-dependent constants and focuses solely on the number of modular operations performed in the entire program. Three commonly used asymptotic notations describe the time complexity of algorithms:

<!-- <p align="center"> -->
   <!-- <img src="./assets/time_complexity/tc_graph.png" align="center" alt="Time Complexity of Algorithms"> -->
   <!-- <p style="text-align: center; font-size: 9px;">Time Complexity of Algorithms</p> -->
<!-- </p> -->

1. **Big-O Notation (Ο):** Describes the worst-case scenario.
2. **Omega Notation (Ω):** Specifies the best-case scenario.
3. **Theta Notation (θ):** Represents the average complexity of an algorithm.

## 3. Learn essential Data Structures and Algorithms

◌ <a href="#31-array">**3.1 - Array**</a><br>◌ <a href="#32-string">**3.2 - String**</a><br>◌ <a href="#33-linked-list">**3.3 - Linked List**</a><br>◌ <a href="#34-searching-algorithm">**3.4 - Searching Algorithm**</a><br>◌ <a href="#35-sorting-algorithm">**3.5 - Sorting Algorithm**</a><br>◌ <a href="#36-divide-and-conquer-algorithm">**3.6 - Divide and Conquer Algorithm**</a><br>◌ <a href="#37-stack">**3.7 - Stack**</a><br>◌ <a href="#38-queue">**3.8 - Queue**</a><br>◌ <a href="#39-tree-data-structure">**3.9 - Tree Data Structure**</a><br>◌ <a href="#310-graph-data-structure">**3.10 - Graph Data Structure**</a><br>◌ <a href="#311-greedy-methodology">**3.11 - Greedy Methodology**</a><br>◌ <a href="#312-recursion">**3.12 - Recursion**</a><br>◌ <a href="#313-backtracking-algorithm">**3.13 - Backtracking Algorithm**</a><br>◌ <a href="#314-dynamic-programming">**3.14 - Dynamic Programming**</a></p>

## 3.1 Array

The array is a fundamental and crucial data structure, presenting a linear arrangement of elements. It serves as a collection of homogeneous data types, with elements allocated contiguous memory. Thanks to this contiguous allocation, accessing any array element occurs in constant time. Each array element is identified by a corresponding index number.

<!-- <p align="center"> -->
   <!-- <img src="./assets/data_structures/array-data-structure.jpg" alt="Array Data Structure"> -->
   <!-- <p style="text-align: center; font-size: 9px;">Array Data Structure</p> -->
<!-- </p> -->

Additional Array Topics to Explore

- **Rotation of Array:** Shifting elements in a circular manner, such as right circular shift where the last element becomes the first.
- **Rearranging an array:** Changing the initial order of elements based on specific conditions or operations.
- **Range queries in the array:** Performing operations on a range of elements, often referred to as range queries.
- **Multidimensional array:** Arrays with more than one dimension, commonly encountered in the form of 2-dimensional arrays, known as matrices.
- **Kadane’s algorithm**
- **Dutch national flag algorithm**

## 3.2 String

A string, essentially a type of array, can be seen as an array of characters. However, it possesses distinct features, such as the last character being a null character to signify the string's end. Unique operations, like concatenation merging two strings into one, further set strings apart.

<!-- img -->

Additional String Concepts to Explore

- **Subsequence and Substring:** A subsequence is derived from a string by deleting one or more elements, while a substring is a contiguous segment of the string.
- **Reverse and Rotation in a String:** Reversing involves interchanging character positions, while rotation shifts elements circularly.
- **Binary String:** Comprising only two types of characters.
- **Palindrome:** A string with elements equidistant from its center being the same.
- **Lexicographic Pattern:** A pattern based on ASCII values or in dictionary order.
- **Pattern Searching:** Advanced topic involving searching for a given pattern within the string.

## 3.3 Linked List

Similar to the aforementioned data structures, a linked list is a linear data structure. However, unlike an array, a linked list doesn't have contiguous memory allocation. Instead, each node in the linked list is assigned to a random memory space, and the previous node maintains a pointer to this node. Direct memory access to any node is not possible, and the linked list is dynamic, allowing for size adjustments at any time. 

<!-- img -->

Linked List Variations to Explore

- **Singly Linked List:** Each node points only to its next node.
- **Circular Linked List:** The last node points back to the head of the linked list.
- **Doubly Linked List:** Each node holds two pointers—one pointing to the next node and the other to the previous node.

## 3.4 Searching Algorithm

Having explored linear data structures, it's time to delve into fundamental and widely used algorithms, starting with searching algorithms.
Searching algorithms aim to locate a specific element in an array, string, linked list, or other data structures. Key searching algorithms include:

<!-- img -->

- **Linear Search:** Iteratively checks for the element from one end to the other.
- **Binary Search:** Divides the data structure into two equal parts to locate the element.
- **Ternary Search:** Divides the array into three parts, determining the segment to search based on partitioning values.

Other notable searching algorithms include:

- Jump Search
- Interpolation Search
- Exponential Search

## 3.5 Sorting Algorithm

Another crucial algorithm is the sorting algorithm, frequently employed when arranging data based on specific conditions becomes necessary. Sorting algorithms are utilized to rearrange a set of homogeneous data, such as sorting an array in increasing or decreasing order.

These algorithms rearrange the elements of a given array or list according to a comparison operator. The comparison operator determines the new order of elements in the respective data structure.

<!-- img -->

Widely Used Sorting Algorithms

- **Bubble Sort**
- **Selection Sort**
- **Insertion Sort**
- **Quick Sort**
- **Merge Sort**

Numerous other sorting algorithms exist, each beneficial in different scenarios.

## 3.6 Divide and Conquer Algorithm

An intriguing and significant algorithm to learn in your programming journey is the Divide and Conquer algorithm. True to its name, it breaks down a problem into parts, solves each subproblem, and then merges the solutions to address the original problem.

<!-- img -->

The algorithmic paradigm of Divide and Conquer involves three key steps:

1. **Divide:** Break the given problem into subproblems of the same type.
2. **Conquer:** Recursively solve these subproblems.
3. **Combine:** Appropriately combine the answers.

This technique is prominently featured in two sorting algorithms—Merge Sort and Quick Sort.

## 3.7 Stack

Transitioning to more complex data structures, let's explore the Stack and Queue.

A Stack is a linear data structure that adheres to a specific order for its operations. This order can be LIFO (Last In First Out) or FILO (First In Last Out).

<!-- img -->

The complexity of the Stack as a data structure arises from its implementation, utilizing other data structures like Arrays, Linked lists, etc., chosen based on the characteristics and features specific to the Stack data structure.

## 3.8 Queue

Similar to a Stack but with distinct characteristics, the Queue is another linear data structure.

A Queue operates on the principle of First In First Out (FIFO) in its individual operations.

<!-- img -->

Different types of queues include:

- **Circular Queue:** The last element is connected to the first element, forming a circular structure.
- **Double-ended Queue (Deque):** Allows operations from both ends of the queue.
- **Priority Queue:** Elements are arranged based on priority, with lower-priority elements dequeued after higher-priority ones.

## 3.9 Tree Data Structure

Having covered the basics of linear data structures, let's delve into non-linear structures, starting with the Tree.

The Tree data structure resembles an inverted tree from nature, featuring a root and leaves. The root is the initial node, and the leaves are at the bottom-most level. Notably, there's only one path between any two nodes in a tree.

<!-- img -->

Based on the maximum number of children a node can have:

- **Binary Tree:** Each node can have a maximum of 2 children.
- **Ternary Tree:** Each node can have a maximum of 3 children.
- **N-ary Tree:** A node can have at most N children.

Additional classifications based on node configuration include:

- **Complete Binary Tree:** All levels are filled, except possibly for the last level, which is filled from the left as much as possible.
- **Perfect Binary Tree:** All levels are filled.
- **Binary Search Tree:** A special binary tree where smaller nodes are on the left, and higher value nodes are on the right.
- **Ternary Search Tree:** Similar to a binary search tree, but with nodes having at most 3 children.

## 3.10 Graph Data Structure

Moving on to another crucial non-linear structure, let's explore the Graph. Unlike the Tree, a Graph lacks a specific root or leaf node and allows traversal in any order.

A Graph is a non-linear structure composed of a finite set of vertices (or nodes) and a set of edges connecting pairs of nodes. It proves invaluable in solving various real-life problems. Graphs can take different forms based on edge orientation and node characteristics.

<!-- img -->

Key concepts to explore:

- **Types of Graphs:** Varying types based on connectivity or weights of nodes.
- **Introduction to BFS and DFS:** Algorithms for traversing through a graph.
- **Cycles in a Graph:** Series of connections leading to a loop.
- **Topological Sorting in the Graph**
- **Minimum Spanning Tree in Graph**

## 3.11 Greedy Methodology

As the name implies, the Greedy methodology constructs the solution incrementally, selecting the next piece that provides the most immediate benefit — the locally optimal choice leading to global solutions.

Well-suited for problems where choosing locally optimal options also results in global optimality. For instance, the Fractional Knapsack Problem employs a local optimal strategy of choosing items with the maximum value-to-weight ratio, leading to a globally optimal solution as fractions are allowed.

<!-- img -->

To delve into the Greedy algorithm, explore these sub-topics:

- **Standard Greedy Algorithms**
- **Greedy Algorithms in Graphs**
- **Greedy Algorithms in Operating Systems**
- **Greedy Algorithms in Arrays**
- **Approximate Greedy Algorithms for NP-complete Problems**

## 3.12 Recursion

Recursion stands out as a vital algorithm leveraging the concept of code reusability and repeated code usage. Its significance extends to being the foundation for many other algorithms, including:

<!-- img -->

- Tree Traversals
- Graph Traversals
- Divide and Conquer Algorithms
- Backtracking Algorithms

To explore Recursion thoroughly, refer to the following articles/links:

- [Recursion](link)
- [Recursive Functions](link)
- [Tail Recursion](link)
- [Towers of Hanoi (TOH)](link)

## 3.13 Backtracking Algorithm

Derived from Recursion, the Backtracking algorithm allows for retracing if a recursive solution fails, exploring alternative solutions. It systematically tries out all possible solutions to find the correct one.

Backtracking is an algorithmic technique that incrementally builds a solution, removing failed solutions that don't meet problem constraints.

<!-- img -->

Key problems to tackle in Backtracking algorithms:

- **Knight’s Tour Problem**
- **Rat in a Maze**
- **N-Queen Problem**
- **Subset Sum Problem**
- **M-Coloring Problem**
- **Hamiltonian Cycle**
- **Sudoku**

## 3.14 Dynamic Programming

Dynamic Programming stands as a crucial algorithm, serving as an optimization over plain recursion. It becomes particularly valuable when a recursive solution involves repeated calls for the same inputs, allowing for optimization.

<!-- img -->

Key concepts to explore in Dynamic Programming:

- **Tabulation vs Memoization**
- **Optimal Substructure Property**
- **Overlapping Subproblems Property**
- **Bitmasking and Dynamic Programming**
- **Bitmasking and Dynamic Programming**
- **Digit DP**

## 4. Practice Consistently and Extensively

Having covered the basics of major data structures and algorithms, it's time to put your knowledge into practice.

>"Practice makes a man perfect."

For learning DSA, consistent and extensive practice is key. Whether considered a separate step or an integral part of the learning process, dedicating time to solving problems and implementing algorithms is essential for mastery.

## 5. Compete to Advance and Become Proficient

Explore and enhance your coding skills on various practicing platforms. Compete, solve challenges, and advance your proficiency on platforms like:

1. [LeetCode](https://leetcode.com/)
2. [Codeforces](https://codeforces.com/)
3. [HackerRank](https://www.hackerrank.com/)
4. [CodeChef](https://www.codechef.com/)
5. [TopCoder](https://www.topcoder.com/)
6. [AtCoder](https://atcoder.jp/)
7. [GeeksforGeeks](https://www.geeksforgeeks.org/)
8. [InterviewBit](https://www.interviewbit.com/)
9. [Exercism](https://exercism.io/)
10. [Project Euler](https://projecteuler.net/)

Competing on these platforms will help you apply your knowledge, face diverse challenges, and continuously improve your problem-solving skills.

## Tips to Boost Your Learning

Throughout the roadmap to learn DSA, consider the following tips to enhance your learning experience:

1. **Master the Fundamentals:** Thoroughly understand the fundamentals of your chosen programming language, including basic syntax, data types, operators, variables, functions, conditional statements, loops, and Object-Oriented Programming (OOP).
2. **Implement Concepts Practically:** Implement each small concept actively. Practice coding to reinforce your understanding of basic programming constructs.
3. **Grasp Complexity Analysis:** Learn how to analyze the complexity of algorithms. Solve multiple questions to practice calculating complexities. Utilize quizzes on Algorithm Analysis for additional practice.
4. **Focus on Logic Building:** Strengthen your logical thinking by solving problems from scratch without referring to solutions or editorials. The more problems you solve independently, the more robust your logic-building skills become.
5. **Overcome Challenges:** Accept that challenges and roadblocks are part of the learning journey. If you're stuck on a problem or topic, read hints and approaches, and try to solve it independently. If needed, refer to the logic and code it yourself. If facing repeated challenges, consider revisiting the related concepts.

Remember, learning DSA is a continuous process, and persistence and problem-solving skills play crucial roles in your success.

## DSA Practice Sheets

### 1. **Striver’s SDE Sheet — Top Coding Interview Problems**
   - [Website Link](https://takeuforward.org/interviews/strivers-sde-sheet-top-coding-interview-problems/)
   - Creator: Raj Vikramaditya (Striver)
   - A compilation of essential coding interview questions in Data Structures & Algorithms. Commonly asked in interviews at prominent companies like Google, Amazon, and Facebook.

### 2. **DSA Sheet by Love Babbar**
   - [Website Link](https://www.geeksforgeeks.org/dsa-sheet-by-love-babbar/)
   - Creator: Love Babbar
   - A comprehensive list of 450 coding questions by a former Amazon Software Engineer. These questions help in understanding Data Structures & Algorithms and are frequently asked in interviews at companies like Amazon, Microsoft, and Google.

### 3. **Apna College DSA Sheet**
   - [Google Sheet Link](https://docs.google.com/spreadsheets/d/1hXserPuxVoWMG9Hs7y8wVdRCJTcj3xMBAEYUOXQ5Xag)
   - Creators: Shradha Didi and Aman Bhaiya
   - A valuable resource with around 400 problems categorized by topic, along with information about companies that have posed these problems.

### 4. **NeetCode 150**
   - [Website Link](https://neetcode.io/practice)
   - Curated by a Google engineer
   - A collection of 150 LeetCode.com questions covering important topics for interviews at FAANG and other big tech companies.

### 5. **DSA Sheet by Arsh (45–60 Days Plan)**
   - [Google Sheet Link](https://docs.google.com/spreadsheets/d/1MGVBJ8HkRbCnU6EQASjJKCqQE8BWng4qgL0n3vCVOxE)
   - Creator: Arsh Goyal
   - A DSA plan with coding problems designed to prepare for interviews in 45–60 days. Arsh has a background in Samsung, CodeChef, and ISRO.

### 6. **AlgoPrep’s 151 Problems Sheet**
   - [Google Sheet Link](https://docs.google.com/spreadsheets/d/1kyHfGGaLTzWspcqMUUS5Httmip7t8LJB0P-uPrRLGos)
   - Compiled by Nishant Bhaiya from AlgoPrep
   - A broad range of coding problems and solutions related to data structures and algorithms, aimed at assisting software development engineers in interview preparation for top tech firms.


## Upcoming Additions

Stay tuned for additional resources and guides tailored for specific programming languages:

## JavaScript - Data Structures and Algorithms

## Python - Data Structures and Algorithms

## C/C++ - Data Structures and Algorithms

## Java - Data Structures and Algorithms
